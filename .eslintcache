[{"/Users/chrischase/Dev/word-search/src/index.js":"1","/Users/chrischase/Dev/word-search/src/reportWebVitals.js":"2","/Users/chrischase/Dev/word-search/src/App.js":"3","/Users/chrischase/Dev/word-search/src/components/GridLetter.js":"4","/Users/chrischase/Dev/word-search/src/utils/gridSetup.js":"5","/Users/chrischase/Dev/word-search/src/components/WordList.js":"6","/Users/chrischase/Dev/word-search/src/utils/utils.js":"7","/Users/chrischase/Dev/word-search/src/utils/matching.js":"8","/Users/chrischase/Dev/word-search/src/components/WordCount.js":"9","/Users/chrischase/Dev/word-search/src/components/PlayAgain.js":"10","/Users/chrischase/Dev/word-search/src/utils/grid.js":"11","/Users/chrischase/Dev/word-search/src/utils/populateGrid.js":"12"},{"size":500,"mtime":1611646243557,"results":"13","hashOfConfig":"14"},{"size":362,"mtime":1611646243558,"results":"15","hashOfConfig":"14"},{"size":4560,"mtime":1613205119377,"results":"16","hashOfConfig":"14"},{"size":391,"mtime":1611646243556,"results":"17","hashOfConfig":"14"},{"size":948,"mtime":1613678883026,"results":"18","hashOfConfig":"14"},{"size":229,"mtime":1611646243556,"results":"19","hashOfConfig":"14"},{"size":733,"mtime":1613205119390,"results":"20","hashOfConfig":"14"},{"size":146,"mtime":1612030958262,"results":"21","hashOfConfig":"14"},{"size":144,"mtime":1613028239821,"results":"22","hashOfConfig":"14"},{"size":140,"mtime":1613029720059,"results":"23","hashOfConfig":"14"},{"size":1394,"mtime":1613678332046,"results":"24","hashOfConfig":"14"},{"size":3524,"mtime":1613678332043,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"1rtdojv",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"28"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"28"},"/Users/chrischase/Dev/word-search/src/index.js",[],["54","55"],"/Users/chrischase/Dev/word-search/src/reportWebVitals.js",[],"/Users/chrischase/Dev/word-search/src/App.js",["56","57","58"],"import './App.css';\nimport React, {useState} from 'react';\n\nimport GridLetter from \"./components/GridLetter\";\nimport WordList from \"./components/WordList\";\nimport WordCount from \"./components/WordCount\";\nimport PlayAgain from \"./components/PlayAgain\";\n\nimport utils from \"./utils/utils\";\nimport matching from \"./utils/matching\";\nimport gridSetup from \"./utils/gridSetup\";\nimport userEvent from \"@testing-library/user-event\";\n\n\nconst StarsDisplay = props => (\n    <>\n        {utils.range(1, props.count).map(starId => <div key={starId} className=\"star\"/>)}\n    </>\n);\n\n\nfunction App() {\n    const MATCHED = 'matched';\n    const CANDIDATE = 'candidate';\n    const AVAILABLE = 'available';\n    const [words, setWords] = useState(gridSetup.getWords());\n    // stores the location of the words in the grid by ids\n    const [wordLocations, setWordLocation] = useState(gridSetup.getWordLocations());\n    // letters in the grid, based on 3x3 grid\n    const [grid, setGrid] = useState(gridSetup.getGrid());\n    // indexes from wordLocations of the words found\n    const [foundWordIndexes, setFoundWordIndexes] = useState([]);\n    // letters selected when trying to find a word\n    const [selectedLetters, setSelectedLetters] = useState([]);\n    // contains the id of the letters for words found\n    const [matchedLetters, setMatchedLetters] = useState([]);\n\n    const resettGame = () => {\n        setWords(gridSetup.getWords());\n        setWordLocation(gridSetup.getWordLocations());\n        setGrid(gridSetup.getGrid());\n        setFoundWordIndexes([]);\n        setSelectedLetters([]);\n        setMatchedLetters([]);\n    }\n\n    const gameComplete = () => {\n        return words.length <= foundWordIndexes.length\n    }\n\n    const onLetterClick = (id, currentStatus) => {\n        console.log('id ', id);\n        console.log('on click candidate Letters ', selectedLetters);\n        const updatedSelection = (utils.toggleLetterSelection(id, selectedLetters));\n        console.log('after click candidate letters', updatedSelection);\n        setSelectedLetters(updatedSelection);\n        detectMatches(updatedSelection);\n    };\n\n    const detectMatches = (selectedLetters) => {\n        // TODO detect multiple matched words\n        wordLocations.forEach((word, index) => {\n            console.log('selection for matching', selectedLetters);\n            // TODO don't update count if word was already found\n            if (matching.wordFound(word, selectedLetters)) {\n                console.log('you got a match');\n                const newMatchedLetters = matchedLetters.concat(selectedLetters);\n                setMatchedLetters(newMatchedLetters);\n                const newFoundWordIndexes = foundWordIndexes.concat(index);\n                setFoundWordIndexes(newFoundWordIndexes);\n                console.log('words length', words.length);\n                console.log('foundIndexes', newFoundWordIndexes.length);\n                if (newFoundWordIndexes.length === words.length) {\n                    console.log('game over');\n                }\n                console.log('matchedLetters', newMatchedLetters);\n                setSelectedLetters([]);\n            }\n        });\n    };\n\n    const numberStatus = (number) => {\n\n        const candidate = selectedLetters.includes(number);\n        const matched = matchedLetters.includes(number);\n        if (matched && candidate) {\n            return CANDIDATE;\n        }\n        if (matched && !candidate) {\n            return MATCHED;\n        }\n        if (!matched && candidate) {\n            return CANDIDATE;\n        }\n        return AVAILABLE\n    };\n\n    return (\n        <div className=\"game\">\n            <div className=\"help\">\n                Click on the letters to find the words\n            </div>\n            <div className=\"body\">\n                <div className=\"left\">\n                    <WordCount total={words.length} found={foundWordIndexes.length}/>\n                    {gameComplete() && <PlayAgain onClick={resettGame}/>}\n                </div>\n                <div className=\"right\">\n                    {grid.map((letter, index) =>\n                        <GridLetter key={index}\n                                    letter={letter}\n                                    id={index}\n                                    status={numberStatus(index)}\n                                    onClick={onLetterClick}\n                        />\n                    )}\n                </div>\n            </div>\n            <div className=\"timer\">Time Remaining: 10</div>\n        </div>\n    );\n}\n\nexport default App;\n","/Users/chrischase/Dev/word-search/src/components/GridLetter.js",[],"/Users/chrischase/Dev/word-search/src/utils/gridSetup.js",["59","60"],"/Users/chrischase/Dev/word-search/src/components/WordList.js",[],"/Users/chrischase/Dev/word-search/src/utils/utils.js",[],"/Users/chrischase/Dev/word-search/src/utils/matching.js",[],"/Users/chrischase/Dev/word-search/src/components/WordCount.js",[],"/Users/chrischase/Dev/word-search/src/components/PlayAgain.js",[],"/Users/chrischase/Dev/word-search/src/utils/grid.js",["61"],"import utils from \"./utils\";\nimport PopulateGrid from \"./populateGrid\";\n\n// const wordLocations = [[0, 1, 2], [2, 5, 8]];\nconst removeDuplicates = (array) => [...new Set(array)];\nconst flatten = (array) => array.reduce((prev, curr) => prev.concat(curr))\n//const locationIndexes = removeDuplicates(flatten(wordLocations));\nconst selectSNextStartLocation = () => 0;\n\n\nconst Grid = {\n    letters: ['F', 'O', 'X', '-', '-', 'O', '-', '-', 'B'],\n    row: 0,\n    columns: 0,\n    size: 0,\n    wordLocations: [],\n    locationIndexes: [],\n    createBlankGrid(rows, columns) {\n        this.rows = rows;\n        this.columns = columns;\n        this.size = rows * columns;\n        this.letters = new Array(this.size).fill('-');\n        return this;\n    },\n    populateWords(words) {\n        words.forEach( word => {\n            const candidateLocation = PopulateGrid.getRandomLocation(this.size);\n            const startLocation = selectSNextStartLocation(word);\n            this.letters.splice(startLocation, word.length, ...word);\n            this.wordLocations = [[0,1,2]];\n\n        });\n        this.locationIndexes = removeDuplicates(flatten(this.wordLocations));\n        return this;\n    },\n    fillBlanks(letterLocations) {\n        this.letters = this.letters\n            .map((e, i) => this.locationIndexes.includes(i) ? e : utils.randomLetter());\n        return this;\n    },\n};\nexport default Grid;","/Users/chrischase/Dev/word-search/src/utils/populateGrid.js",["62","63"],"const PopulateGrid = {\n    getRandomLocation(gridSize) {\n        Math.floor(Math.random() * gridSize)\n    },\n    getAvailableDirections(failedDirections = []) {\n        // directions can be N E S W\n        // N writes from bottom to top. E writes left to right, S top to bottom, W right to left\n        // TODO add diagonals NE, SE, SW, NW\n        const directions = ['N', 'E', \"S\", 'W'];\n        const availableDirections = directions.filter(d => !failedDirections.includes(d));\n        return availableDirections;\n    },\n    getRandomDirection(directions) {\n        if (directions.length === 1) {\n            return directions[0];\n        }\n        return directions[Math.floor(Math.random() * directions.length)];\n    },\n    // TODO write more tests for this\n    findNextDirection(grid, position, word, directions) {\n        const failedDirections = [];\n        let remainingDirections = directions;\n        // TODO change to forEach\n        for (let i = 0; i <= directions.length; i++) {\n            const candidateDirection = this.getRandomDirection(remainingDirections);\n            const directionOK = this.checkDirections(candidateDirection, grid.rows, grid.columns, position, word.length);\n            if (directionOK) {\n                return candidateDirection;\n            }\n            failedDirections.push(candidateDirection);\n            remainingDirections = this.getAvailableDirections(failedDirections);\n        }\n        return false;\n    },\n    insertWord(grid, position, direction, word) {\n        const letters = [...word];\n        let currentPosition = position;\n        letters.forEach(letter => {\n            grid.letters[currentPosition] = letter;\n            currentPosition = this.calculateNextPosition(grid, direction, currentPosition);\n        });\n    },\n    calculateNextPosition(grid, direction, currentPosition) {\n        switch (direction) {\n            case 'N':\n                return currentPosition - grid.columns;\n            case 'E':\n                return currentPosition + 1;\n            case 'S':\n                return currentPosition + grid.columns;\n            case 'W':\n                return currentPosition -1;\n\n        }\n    },\n    checkDirections(direction, rows, columns, position, wordLen) {\n        // const wordLen = word.length;\n        switch (direction) {\n            case 'N':\n                if (position - ((wordLen - 1) * columns) >= 0) {\n                    return true;\n                }\n                return false;\n            case 'E':\n                const rowEnd = position - (position % columns) + (columns - 1);\n                if (position + (wordLen - 1) > rowEnd) {\n                    return false;\n                }\n                return true;\n            case 'S':\n                // TODO which way of doing this is better\n                if (position + ((wordLen - 1) * columns) > (rows * columns) - 1) {\n                    return false;\n                }\n                // const wordEnd = position + ((wordLen - 1) * columns);\n                // const columnEnd = position + ((rows - (Math.floor(position / rows) + 1)) * columns);\n                // if (wordEnd > columnEnd) {\n                //     return false\n                // }\n                return true;\n            case 'W':\n                const rowStart = position - (position % columns);\n                if (position - (wordLen - 1) < rowStart) {\n                    return false\n                }\n                return true;\n        }\n    }\n}\n\n\nexport default PopulateGrid;\n",{"ruleId":"64","replacedBy":"65"},{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","severity":1,"message":"69","line":5,"column":8,"nodeType":"70","messageId":"71","endLine":5,"endColumn":16},{"ruleId":"68","severity":1,"message":"72","line":12,"column":8,"nodeType":"70","messageId":"71","endLine":12,"endColumn":17},{"ruleId":"68","severity":1,"message":"73","line":15,"column":7,"nodeType":"70","messageId":"71","endLine":15,"endColumn":19},{"ruleId":"68","severity":1,"message":"74","line":10,"column":7,"nodeType":"70","messageId":"71","endLine":10,"endColumn":22},{"ruleId":"68","severity":1,"message":"75","line":19,"column":15,"nodeType":"70","messageId":"71","endLine":19,"endColumn":28},{"ruleId":"68","severity":1,"message":"76","line":27,"column":19,"nodeType":"70","messageId":"71","endLine":27,"endColumn":36},{"ruleId":"77","severity":1,"message":"78","line":44,"column":9,"nodeType":"79","messageId":"80","endLine":54,"endColumn":10},{"ruleId":"77","severity":1,"message":"78","line":58,"column":9,"nodeType":"79","messageId":"80","endLine":87,"endColumn":10},"no-native-reassign",["81"],"no-negated-in-lhs",["82"],"no-unused-vars","'WordList' is defined but never used.","Identifier","unusedVar","'userEvent' is defined but never used.","'StarsDisplay' is assigned a value but never used.","'locationIndexes' is assigned a value but never used.","'nextDirection' is assigned a value but never used.","'candidateLocation' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-global-assign","no-unsafe-negation"]