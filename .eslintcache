[{"/Users/chrischase/Dev/word-search/src/index.js":"1","/Users/chrischase/Dev/word-search/src/reportWebVitals.js":"2","/Users/chrischase/Dev/word-search/src/App.js":"3","/Users/chrischase/Dev/word-search/src/components/GridLetter.js":"4","/Users/chrischase/Dev/word-search/src/utils/gridSetup.js":"5","/Users/chrischase/Dev/word-search/src/components/WordList.js":"6","/Users/chrischase/Dev/word-search/src/utils/utils.js":"7","/Users/chrischase/Dev/word-search/src/utils/matching.js":"8","/Users/chrischase/Dev/word-search/src/components/WordCount.js":"9","/Users/chrischase/Dev/word-search/src/components/PlayAgain.js":"10","/Users/chrischase/Dev/word-search/src/utils/grid.js":"11","/Users/chrischase/Dev/word-search/src/utils/populateGrid.js":"12"},{"size":500,"mtime":1611646243557,"results":"13","hashOfConfig":"14"},{"size":362,"mtime":1611646243558,"results":"15","hashOfConfig":"14"},{"size":4560,"mtime":1613205119377,"results":"16","hashOfConfig":"14"},{"size":391,"mtime":1611646243556,"results":"17","hashOfConfig":"14"},{"size":1137,"mtime":1613811428866,"results":"18","hashOfConfig":"14"},{"size":229,"mtime":1611646243556,"results":"19","hashOfConfig":"14"},{"size":733,"mtime":1613205119390,"results":"20","hashOfConfig":"14"},{"size":146,"mtime":1612030958262,"results":"21","hashOfConfig":"14"},{"size":144,"mtime":1613028239821,"results":"22","hashOfConfig":"14"},{"size":140,"mtime":1613029720059,"results":"23","hashOfConfig":"14"},{"size":2044,"mtime":1613811713269,"results":"24","hashOfConfig":"14"},{"size":3524,"mtime":1613678332043,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"1rtdojv",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"28"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"50","messages":"51","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"52","usedDeprecatedRules":"28"},"/Users/chrischase/Dev/word-search/src/index.js",[],["53","54"],"/Users/chrischase/Dev/word-search/src/reportWebVitals.js",[],"/Users/chrischase/Dev/word-search/src/App.js",["55","56","57"],"import './App.css';\nimport React, {useState} from 'react';\n\nimport GridLetter from \"./components/GridLetter\";\nimport WordList from \"./components/WordList\";\nimport WordCount from \"./components/WordCount\";\nimport PlayAgain from \"./components/PlayAgain\";\n\nimport utils from \"./utils/utils\";\nimport matching from \"./utils/matching\";\nimport gridSetup from \"./utils/gridSetup\";\nimport userEvent from \"@testing-library/user-event\";\n\n\nconst StarsDisplay = props => (\n    <>\n        {utils.range(1, props.count).map(starId => <div key={starId} className=\"star\"/>)}\n    </>\n);\n\n\nfunction App() {\n    const MATCHED = 'matched';\n    const CANDIDATE = 'candidate';\n    const AVAILABLE = 'available';\n    const [words, setWords] = useState(gridSetup.getWords());\n    // stores the location of the words in the grid by ids\n    const [wordLocations, setWordLocation] = useState(gridSetup.getWordLocations());\n    // letters in the grid, based on 3x3 grid\n    const [grid, setGrid] = useState(gridSetup.getGrid());\n    // indexes from wordLocations of the words found\n    const [foundWordIndexes, setFoundWordIndexes] = useState([]);\n    // letters selected when trying to find a word\n    const [selectedLetters, setSelectedLetters] = useState([]);\n    // contains the id of the letters for words found\n    const [matchedLetters, setMatchedLetters] = useState([]);\n\n    const resettGame = () => {\n        setWords(gridSetup.getWords());\n        setWordLocation(gridSetup.getWordLocations());\n        setGrid(gridSetup.getGrid());\n        setFoundWordIndexes([]);\n        setSelectedLetters([]);\n        setMatchedLetters([]);\n    }\n\n    const gameComplete = () => {\n        return words.length <= foundWordIndexes.length\n    }\n\n    const onLetterClick = (id, currentStatus) => {\n        console.log('id ', id);\n        console.log('on click candidate Letters ', selectedLetters);\n        const updatedSelection = (utils.toggleLetterSelection(id, selectedLetters));\n        console.log('after click candidate letters', updatedSelection);\n        setSelectedLetters(updatedSelection);\n        detectMatches(updatedSelection);\n    };\n\n    const detectMatches = (selectedLetters) => {\n        // TODO detect multiple matched words\n        wordLocations.forEach((word, index) => {\n            console.log('selection for matching', selectedLetters);\n            // TODO don't update count if word was already found\n            if (matching.wordFound(word, selectedLetters)) {\n                console.log('you got a match');\n                const newMatchedLetters = matchedLetters.concat(selectedLetters);\n                setMatchedLetters(newMatchedLetters);\n                const newFoundWordIndexes = foundWordIndexes.concat(index);\n                setFoundWordIndexes(newFoundWordIndexes);\n                console.log('words length', words.length);\n                console.log('foundIndexes', newFoundWordIndexes.length);\n                if (newFoundWordIndexes.length === words.length) {\n                    console.log('game over');\n                }\n                console.log('matchedLetters', newMatchedLetters);\n                setSelectedLetters([]);\n            }\n        });\n    };\n\n    const numberStatus = (number) => {\n\n        const candidate = selectedLetters.includes(number);\n        const matched = matchedLetters.includes(number);\n        if (matched && candidate) {\n            return CANDIDATE;\n        }\n        if (matched && !candidate) {\n            return MATCHED;\n        }\n        if (!matched && candidate) {\n            return CANDIDATE;\n        }\n        return AVAILABLE\n    };\n\n    return (\n        <div className=\"game\">\n            <div className=\"help\">\n                Click on the letters to find the words\n            </div>\n            <div className=\"body\">\n                <div className=\"left\">\n                    <WordCount total={words.length} found={foundWordIndexes.length}/>\n                    {gameComplete() && <PlayAgain onClick={resettGame}/>}\n                </div>\n                <div className=\"right\">\n                    {grid.map((letter, index) =>\n                        <GridLetter key={index}\n                                    letter={letter}\n                                    id={index}\n                                    status={numberStatus(index)}\n                                    onClick={onLetterClick}\n                        />\n                    )}\n                </div>\n            </div>\n            <div className=\"timer\">Time Remaining: 10</div>\n        </div>\n    );\n}\n\nexport default App;\n","/Users/chrischase/Dev/word-search/src/components/GridLetter.js",[],"/Users/chrischase/Dev/word-search/src/utils/gridSetup.js",["58","59","60"],"/Users/chrischase/Dev/word-search/src/components/WordList.js",[],"/Users/chrischase/Dev/word-search/src/utils/utils.js",[],"/Users/chrischase/Dev/word-search/src/utils/matching.js",[],"/Users/chrischase/Dev/word-search/src/components/WordCount.js",[],"/Users/chrischase/Dev/word-search/src/components/PlayAgain.js",[],"/Users/chrischase/Dev/word-search/src/utils/grid.js",["61","62","63"],"/Users/chrischase/Dev/word-search/src/utils/populateGrid.js",["64","65"],"const PopulateGrid = {\n    getRandomLocation(gridSize) {\n        Math.floor(Math.random() * gridSize)\n    },\n    getAvailableDirections(failedDirections = []) {\n        // directions can be N E S W\n        // N writes from bottom to top. E writes left to right, S top to bottom, W right to left\n        // TODO add diagonals NE, SE, SW, NW\n        const directions = ['N', 'E', \"S\", 'W'];\n        const availableDirections = directions.filter(d => !failedDirections.includes(d));\n        return availableDirections;\n    },\n    getRandomDirection(directions) {\n        if (directions.length === 1) {\n            return directions[0];\n        }\n        return directions[Math.floor(Math.random() * directions.length)];\n    },\n    // TODO write more tests for this\n    findNextDirection(grid, position, word, directions) {\n        const failedDirections = [];\n        let remainingDirections = directions;\n        // TODO change to forEach\n        for (let i = 0; i <= directions.length; i++) {\n            const candidateDirection = this.getRandomDirection(remainingDirections);\n            const directionOK = this.checkDirections(candidateDirection, grid.rows, grid.columns, position, word.length);\n            if (directionOK) {\n                return candidateDirection;\n            }\n            failedDirections.push(candidateDirection);\n            remainingDirections = this.getAvailableDirections(failedDirections);\n        }\n        return false;\n    },\n    insertWord(grid, position, direction, word) {\n        const letters = [...word];\n        let currentPosition = position;\n        letters.forEach(letter => {\n            grid.letters[currentPosition] = letter;\n            currentPosition = this.calculateNextPosition(grid, direction, currentPosition);\n        });\n    },\n    calculateNextPosition(grid, direction, currentPosition) {\n        switch (direction) {\n            case 'N':\n                return currentPosition - grid.columns;\n            case 'E':\n                return currentPosition + 1;\n            case 'S':\n                return currentPosition + grid.columns;\n            case 'W':\n                return currentPosition -1;\n\n        }\n    },\n    checkDirections(direction, rows, columns, position, wordLen) {\n        // const wordLen = word.length;\n        switch (direction) {\n            case 'N':\n                if (position - ((wordLen - 1) * columns) >= 0) {\n                    return true;\n                }\n                return false;\n            case 'E':\n                const rowEnd = position - (position % columns) + (columns - 1);\n                if (position + (wordLen - 1) > rowEnd) {\n                    return false;\n                }\n                return true;\n            case 'S':\n                // TODO which way of doing this is better\n                if (position + ((wordLen - 1) * columns) > (rows * columns) - 1) {\n                    return false;\n                }\n                // const wordEnd = position + ((wordLen - 1) * columns);\n                // const columnEnd = position + ((rows - (Math.floor(position / rows) + 1)) * columns);\n                // if (wordEnd > columnEnd) {\n                //     return false\n                // }\n                return true;\n            case 'W':\n                const rowStart = position - (position % columns);\n                if (position - (wordLen - 1) < rowStart) {\n                    return false\n                }\n                return true;\n        }\n    }\n}\n\n\nexport default PopulateGrid;\n",{"ruleId":"66","replacedBy":"67"},{"ruleId":"68","replacedBy":"69"},{"ruleId":"70","severity":1,"message":"71","line":5,"column":8,"nodeType":"72","messageId":"73","endLine":5,"endColumn":16},{"ruleId":"70","severity":1,"message":"74","line":12,"column":8,"nodeType":"72","messageId":"73","endLine":12,"endColumn":17},{"ruleId":"70","severity":1,"message":"75","line":15,"column":7,"nodeType":"72","messageId":"73","endLine":15,"endColumn":19},{"ruleId":"70","severity":1,"message":"76","line":2,"column":8,"nodeType":"72","messageId":"73","endLine":2,"endColumn":20},{"ruleId":"70","severity":1,"message":"77","line":5,"column":11,"nodeType":"72","messageId":"73","endLine":5,"endColumn":21},{"ruleId":"70","severity":1,"message":"78","line":10,"column":7,"nodeType":"72","messageId":"73","endLine":10,"endColumn":22},{"ruleId":"70","severity":1,"message":"79","line":7,"column":7,"nodeType":"72","messageId":"73","endLine":7,"endColumn":23},{"ruleId":"70","severity":1,"message":"80","line":8,"column":7,"nodeType":"72","messageId":"73","endLine":8,"endColumn":14},{"ruleId":"70","severity":1,"message":"81","line":30,"column":15,"nodeType":"72","messageId":"73","endLine":30,"endColumn":28},{"ruleId":"82","severity":1,"message":"83","line":44,"column":9,"nodeType":"84","messageId":"85","endLine":54,"endColumn":10},{"ruleId":"82","severity":1,"message":"83","line":58,"column":9,"nodeType":"84","messageId":"85","endLine":87,"endColumn":10},"no-native-reassign",["86"],"no-negated-in-lhs",["87"],"no-unused-vars","'WordList' is defined but never used.","Identifier","unusedVar","'userEvent' is defined but never used.","'StarsDisplay' is assigned a value but never used.","'PopulateGrid' is defined but never used.","'directions' is assigned a value but never used.","'locationIndexes' is assigned a value but never used.","'removeDuplicates' is assigned a value but never used.","'flatten' is assigned a value but never used.","'nextDirection' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-global-assign","no-unsafe-negation"]